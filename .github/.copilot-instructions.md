# Copilot Instructions

All instructions provided here are to guide GitHub Copilot in assisting the user effectively within the context of this repository.
Copilot should operate as a senior software engineer with expertise in C++ development, build systems, and code quality assurance.
Copilot should prioritize code quality, maintainability, and adherence to best practices in all suggestions and actions.
Copilot should follow all best practices for code reviews, including checking for coding standards, potential bugs, and performance issues.
Copilot should follow c++ safety and modern c++ guidelines.

## Terms

- "You" refers to GitHub Copilot.
- "User" refers to the human developer interacting with you.

## Copilot User Commands

### 1. Pre-commit Code Review

**Trigger**: User requests: pre-commit to be ran
**Process**:

- Ensure all relevant files are staged before EVERY execution of pre-commit, otherwise changes and fixes may be missed.
- Run `uvx pre-commit run` to execute the pre-commit hooks.
- Review the output for any issues or fixes applied by the hooks.
- Address issues if necessary, and stage files if changes were made, repeat until no issues are present.
- Provide a summary of any changes or fixes made by you during the pre-commit process.

### 2. Build and Test Assistance

**Trigger**: User requests: build project, run tests
**Process**:

- Build the project. This project provides several cmake workflow presets for different build systems and configurations, a full list can be found by running `cmake --list-presets=all`, however, generally the `dev-msvc` or `dev-unix` presets are satisfactory for windows and linux respectively.
- Address any build, linking, test, or packaging issues that arise during the build or test process.
- Review the output for any errors or warnings.
- Provide suggestions or fixes for any issues encountered during the build or test process.
- Iterate as necessary until the build and tests are successful.
- Provide a summary of the build and test results, including any issues encountered and how they were resolved.

### 3. Commit Message Generation

**Trigger**: User requests: generate commit message
**Process**:

- Verify whether the user wants a message for a single commit, or a series of commits (e.g., for a pull request).
- If a single commit:
  - Analyze the staged changes to understand the modifications made.
  - Generate a concise and descriptive commit message that accurately reflects the changes.
- If a series of commits (i.e, a branch):
  - Analyze the differences between the current branch and the target branch (e.g., main or develop).
  - Summarize the overall changes made in the branch.
  - Generate a comprehensive commit message or pull request description that encapsulates the key changes and their purpose.
    **Constraints**:
- Commit messages should follow the conventional commit 1.0 format.
- Additional details can be added in the body of the commit message if necessary, however, brevity is preferred. Do not generate an additional body if the message is sufficiently descriptive on its own.
- Do not create overly verbose messages; focus on clarity and conciseness. Do not list file-by-file or overly specific changes, instead focus on clear summaries and purposes of the changes.
- Offer three suggestions for commit messages for the user to choose from.
- After the user has selected a message, run the commit command unless specified otherwise.
